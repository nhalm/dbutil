# Cursor Rules for dbutil-gen Development

## Project Overview
This is a database-first code generator for PostgreSQL that creates type-safe Go repositories with built-in pagination. The project follows a strict 7-step development plan with specific agent handoffs.

## Core Principles

### 1. Step-by-Step Development
- **CRITICAL**: Each agent works on ONE step only from DEVELOPMENT_PLAN.md
- Always read PRD_DATABASE_GENERATOR.md Implementation Status first
- Update the PRD with detailed implementation notes when completing a step
- Focus ONLY on assigned step deliverables - do not work on future steps
- Test thoroughly before handing off to next agent

### 2. Makefile-First Development
- **ALWAYS** examine the Makefile first before implementing custom solutions
- Use `make` targets for testing, generation, and validation (build, test, integration-test, test-setup, clean)
- Never create custom debugging approaches when Makefile targets exist
- Run `make dev-setup` for complete development environment setup

### 3. Database-First Architecture
- PostgreSQL schema introspection drives all code generation
- UUID v7 primary keys are REQUIRED for pagination
- Reject tables without UUID primary keys with clear error messages
- Support all PostgreSQL data types with proper Go type mapping

### 4. Zero-Dependency Pagination
- Pagination logic is generated INLINE in repository files
- No external pagination dependencies - only pgx
- Use shared pagination.go file with private utility functions
- Cursor-based pagination with base64-encoded UUID v7 cursors

## Development Workflow

### Before Starting Any Work
1. Read DEVELOPMENT_PLAN.md to understand current step
2. Check PRD_DATABASE_GENERATOR.md Implementation Status
3. Run `make clean && make dev-setup` to ensure clean environment
4. Verify which step you're working on and what previous steps completed

### During Development
1. Focus ONLY on current step deliverables
2. Write comprehensive tests for all new functionality
3. Use existing test infrastructure in test/sql/init.sql
4. Test against real PostgreSQL database using Docker Compose
5. Follow Go best practices and proper error handling

### Before Completing a Step
1. Verify ALL deliverables are complete
2. Run full test suite: `make test && make integration-test`
3. Update PRD_DATABASE_GENERATOR.md with implementation notes
4. Document decisions and handoff information
5. Ensure next agent can build on your work immediately

## Code Standards

### Generated Code Quality
- Use `*_generated.go` naming pattern for all generated files
- Include generation header: `// Code generated by dbutil-gen. DO NOT EDIT.`
- Format all code with `go/format.Source()`
- Generate clean, idiomatic Go code with proper imports
- Include necessary struct tags (json, db)

### Repository Pattern
- Generate repositories with constructor functions
- Include all CRUD operations (Create, Get, Update, Delete, List)
- Generate both List() and ListPaginated() methods
- Implement GetID() method with value receiver for pagination compatibility
- Use pgx for all database operations

### Error Handling
- Provide clear, actionable error messages
- Handle connection failures gracefully
- Validate UUID primary key requirements
- Include context in all error messages

## File Structure Rules

### Generated Files (Overwritten Each Run)
- `*_generated.go` - Repository files for each table
- `pagination.go` - Shared pagination types and utilities (generated once per package)
- `types_generated.go` - Common types and interfaces

### Never Touch Files
- Any file without `_generated.go` suffix
- User's custom repository extensions
- Existing database schemas

### Configuration
- Support both CLI flags and YAML configuration files
- Environment variable support for DATABASE_URL
- Include/exclude patterns for table filtering
- Verbose logging for debugging

## Testing Requirements

### Unit Tests
- Test all type mappings (PostgreSQL → Go)
- Test code generation templates
- Test SQL parsing and analysis
- Mock database connections where appropriate

### Integration Tests
- Test against real PostgreSQL database
- Use test/sql/init.sql schema for comprehensive coverage
- Test complete generation pipeline end-to-end
- Verify generated code compiles and runs

### Test Database
- Connection: `postgres://dbutil:dbutil_test_password@localhost:5432/dbutil_test`
- Schema includes all PostgreSQL types and edge cases
- Pre-populated with realistic test data
- Use `make test-setup` to start test infrastructure

## Architecture Decisions

### Pagination Implementation
- **DECISION**: Inline pagination code generation (no external dependencies)
- **RATIONALE**: Zero dependencies, better performance, full control
- **IMPLEMENTATION**: Shared pagination.go with private utility functions

### Code Generation Strategy
- **DECISION**: Template-based generation with proper Go formatting
- **RATIONALE**: Maintainable, extensible, produces clean code
- **IMPLEMENTATION**: Separate templates for CRUD, pagination, and queries

### Primary Key Requirements
- **DECISION**: UUID v7 primary keys only
- **RATIONALE**: Time-ordered pagination, consistent sorting, modern practice
- **IMPLEMENTATION**: Validation during table introspection

## Common Pitfalls to Avoid

### Development Process
- ❌ Working on multiple steps simultaneously
- ❌ Skipping testing or documentation
- ❌ Not updating PRD with implementation notes
- ❌ Creating custom solutions when Makefile targets exist

### Code Generation
- ❌ Creating external pagination dependencies
- ❌ Generating code that doesn't compile
- ❌ Missing proper imports or formatting
- ❌ Not handling edge cases (nullable types, arrays)

### Database Integration
- ❌ Not validating UUID primary keys
- ❌ Ignoring PostgreSQL type nuances
- ❌ Not testing against real database
- ❌ Missing connection error handling

## Current Project Status

### Completed Steps (As of Last Update)
- ✅ Step 1: Test Infrastructure Setup
- ✅ Step 2: Core Type System & Database Introspection  
- ✅ Step 3: Code Generation Engine
- ✅ Step 4: Pagination Integration
- ✅ Step 5: CLI Integration & End-to-End Testing
- ✅ Step 6.1: SQL File Parsing with sqlc-style Annotations
- ✅ Step 6.2: Query Analyzer with PostgreSQL EXPLAIN

### Current Focus
- Step 6.3-6.6: Complete query-based code generation
- Step 7: Documentation & Polish

### Key Files to Understand
- `DEVELOPMENT_PLAN.md` - Step-by-step development process
- `PRD_DATABASE_GENERATOR.md` - Requirements and implementation status
- `AGENT_PROMPTS.md` - Exact prompts for each development step
- `Makefile` - Build automation and testing infrastructure
- `gen/` directory - Core code generation logic

## Success Criteria
- Generated code compiles without errors
- All tests pass (unit and integration)
- CLI tool works end-to-end with real databases
- Zero external dependencies for pagination
- Comprehensive error handling and user feedback
- Performance target: <30 seconds for 100 tables

## Emergency Procedures
If you get stuck or confused:
1. Read the current step in DEVELOPMENT_PLAN.md
2. Check PRD_DATABASE_GENERATOR.md for context
3. Run `make clean && make dev-setup` to reset environment
4. Focus on the specific step deliverables only
5. Ask for clarification on requirements before proceeding

Remember: The goal is steady, incremental progress with each step building a solid foundation for the next agent. 