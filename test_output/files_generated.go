// Code generated by dbutil-gen. DO NOT EDIT.
// Source: table files

package repositories

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Files represents a row from the files table
type Files struct {
	Id               uuid.UUID          `json:"id" db:"id"`
	UserId           uuid.UUID          `json:"user_id" db:"user_id"`
	Filename         string             `json:"filename" db:"filename"`
	OriginalFilename string             `json:"original_filename" db:"original_filename"`
	MimeType         string             `json:"mime_type" db:"mime_type"`
	FileSize         int64              `json:"file_size" db:"file_size"`
	FileHash         string             `json:"file_hash" db:"file_hash"`
	StoragePath      string             `json:"storage_path" db:"storage_path"`
	IsPublic         pgtype.Bool        `json:"is_public" db:"is_public"`
	DownloadCount    pgtype.Int4        `json:"download_count" db:"download_count"`
	Metadata         *json.RawMessage   `json:"metadata" db:"metadata"`
	CreatedAt        pgtype.Timestamptz `json:"created_at" db:"created_at"`
}

// GetID returns the ID of the Files for pagination
func (f Files) GetID() uuid.UUID {
	return f.Id
}

// FilesRepository provides database operations for files
type FilesRepository struct {
	conn *pgxpool.Pool
}

// NewFilesRepository creates a new FilesRepository
func NewFilesRepository(conn *pgxpool.Pool) *FilesRepository {
	return &FilesRepository{
		conn: conn,
	}
}

// GetByID retrieves a Files by its ID
func (r *FilesRepository) GetByID(ctx context.Context, id uuid.UUID) (*Files, error) {
	query := `
		SELECT id, user_id, filename, original_filename, mime_type, file_size, file_hash, storage_path, is_public, download_count, metadata, created_at
		FROM files
		WHERE id = $1
	`

	var f Files
	err := r.conn.QueryRow(ctx, query, id).Scan(&f.Id, &f.UserId, &f.Filename, &f.OriginalFilename, &f.MimeType, &f.FileSize, &f.FileHash, &f.StoragePath, &f.IsPublic, &f.DownloadCount, &f.Metadata, &f.CreatedAt)
	if err != nil {
		return nil, err
	}

	return &f, nil
}

// CreateFilesParams holds parameters for creating a Files
type CreateFilesParams struct {
	UserId           uuid.UUID `json:"user_id" db:"user_id"`
	Filename         string    `json:"filename" db:"filename"`
	OriginalFilename string    `json:"original_filename" db:"original_filename"`
	MimeType         string    `json:"mime_type" db:"mime_type"`
	FileSize         int64     `json:"file_size" db:"file_size"`
	FileHash         string    `json:"file_hash" db:"file_hash"`
	StoragePath      string    `json:"storage_path" db:"storage_path"`
}

// Create creates a new Files
func (r *FilesRepository) Create(ctx context.Context, params CreateFilesParams) (*Files, error) {
	query := `
		INSERT INTO files (user_id, filename, original_filename, mime_type, file_size, file_hash, storage_path)
		VALUES ($1, $2, $3, $4, $5, $6, $7)
		RETURNING id, user_id, filename, original_filename, mime_type, file_size, file_hash, storage_path, is_public, download_count, metadata, created_at
	`

	var f Files
	err := r.conn.QueryRow(ctx, query, params.UserId, params.Filename, params.OriginalFilename, params.MimeType, params.FileSize, params.FileHash, params.StoragePath).Scan(&f.Id, &f.UserId, &f.Filename, &f.OriginalFilename, &f.MimeType, &f.FileSize, &f.FileHash, &f.StoragePath, &f.IsPublic, &f.DownloadCount, &f.Metadata, &f.CreatedAt)
	if err != nil {
		return nil, err
	}

	return &f, nil
}

// UpdateFilesParams holds parameters for updating a Files
type UpdateFilesParams struct {
	UserId           uuid.UUID          `json:"user_id" db:"user_id"`
	Filename         string             `json:"filename" db:"filename"`
	OriginalFilename string             `json:"original_filename" db:"original_filename"`
	MimeType         string             `json:"mime_type" db:"mime_type"`
	FileSize         int64              `json:"file_size" db:"file_size"`
	FileHash         string             `json:"file_hash" db:"file_hash"`
	StoragePath      string             `json:"storage_path" db:"storage_path"`
	IsPublic         pgtype.Bool        `json:"is_public" db:"is_public"`
	DownloadCount    pgtype.Int4        `json:"download_count" db:"download_count"`
	Metadata         *json.RawMessage   `json:"metadata" db:"metadata"`
	CreatedAt        pgtype.Timestamptz `json:"created_at" db:"created_at"`
}

// Update updates a Files by ID
func (r *FilesRepository) Update(ctx context.Context, id uuid.UUID, params UpdateFilesParams) (*Files, error) {
	query := `
		UPDATE files
		SET user_id = $1, filename = $2, original_filename = $3, mime_type = $4, file_size = $5, file_hash = $6, storage_path = $7, is_public = $8, download_count = $9, metadata = $10, created_at = $11
		WHERE id = $12
		RETURNING id, user_id, filename, original_filename, mime_type, file_size, file_hash, storage_path, is_public, download_count, metadata, created_at
	`

	var f Files
	err := r.conn.QueryRow(ctx, query, params.UserId, params.Filename, params.OriginalFilename, params.MimeType, params.FileSize, params.FileHash, params.StoragePath, params.IsPublic, params.DownloadCount, params.Metadata, params.CreatedAt, id).Scan(&f.Id, &f.UserId, &f.Filename, &f.OriginalFilename, &f.MimeType, &f.FileSize, &f.FileHash, &f.StoragePath, &f.IsPublic, &f.DownloadCount, &f.Metadata, &f.CreatedAt)
	if err != nil {
		return nil, err
	}

	return &f, nil
}

// Delete deletes a Files by ID
func (r *FilesRepository) Delete(ctx context.Context, id uuid.UUID) error {
	query := `
		DELETE FROM files
		WHERE id = $1
	`

	_, err := r.conn.Exec(ctx, query, id)
	return err
}

// List retrieves all Filess
func (r *FilesRepository) List(ctx context.Context) ([]Files, error) {
	query := `
		SELECT id, user_id, filename, original_filename, mime_type, file_size, file_hash, storage_path, is_public, download_count, metadata, created_at
		FROM files
		ORDER BY id ASC
	`

	rows, err := r.conn.Query(ctx, query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var results []Files
	for rows.Next() {
		var f Files
		err := rows.Scan(&f.Id, &f.UserId, &f.Filename, &f.OriginalFilename, &f.MimeType, &f.FileSize, &f.FileHash, &f.StoragePath, &f.IsPublic, &f.DownloadCount, &f.Metadata, &f.CreatedAt)
		if err != nil {
			return nil, err
		}
		results = append(results, f)
	}

	return results, rows.Err()
}

// ListPaginated retrieves Filess with cursor-based pagination
func (r *FilesRepository) ListPaginated(ctx context.Context, params PaginationParams) (*PaginationResult[Files], error) {
	// Validate parameters
	if err := validatePaginationParams(params); err != nil {
		return nil, err
	}

	// Set default limit
	limit := params.Limit
	if limit <= 0 {
		limit = 20
	}
	if limit > 100 {
		limit = 100
	}

	// Parse cursor if provided
	var cursor *uuid.UUID
	if params.Cursor != "" {
		cursorUUID, err := decodeCursor(params.Cursor)
		if err != nil {
			return nil, fmt.Errorf("invalid cursor format: %w", err)
		}
		cursor = &cursorUUID
	}

	// Execute query with limit + 1 to check if there are more items
	query := `
		SELECT id, user_id, filename, original_filename, mime_type, file_size, file_hash, storage_path, is_public, download_count, metadata, created_at
		FROM files
		WHERE ($1::uuid IS NULL OR id > $1)
		ORDER BY id ASC
		LIMIT $2
	`

	rows, err := r.conn.Query(ctx, query, cursor, int32(limit+1))
	if err != nil {
		return nil, fmt.Errorf("pagination query failed: %w", err)
	}
	defer rows.Close()

	var items []Files
	for rows.Next() {
		var f Files
		err := rows.Scan(&f.Id, &f.UserId, &f.Filename, &f.OriginalFilename, &f.MimeType, &f.FileSize, &f.FileHash, &f.StoragePath, &f.IsPublic, &f.DownloadCount, &f.Metadata, &f.CreatedAt)
		if err != nil {
			return nil, err
		}
		items = append(items, f)
	}

	if err := rows.Err(); err != nil {
		return nil, err
	}

	// Check if there are more items
	hasMore := len(items) > limit
	if hasMore {
		items = items[:limit] // Remove the extra item
	}

	// Generate next cursor if there are more items
	var nextCursor string
	if hasMore && len(items) > 0 {
		lastItem := items[len(items)-1]
		nextCursor = encodeCursor(lastItem.GetID())
	}

	return &PaginationResult[Files]{
		Items:      items,
		HasMore:    hasMore,
		NextCursor: nextCursor,
	}, nil
}
